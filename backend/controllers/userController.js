//import User from '../data/models/userModel.js'
const User = require('../data/models/userModel.js')
//import asyncHandler from 'express-async-handler'
const asyncHandler =  require('express-async-handler')
//import generateToken from '../utils/generateTokens.js'
const generateToken = require('../utils/generateTokens.js')
//import bcrypt from 'bcryptjs'
const bcrypt = require('bcryptjs')
//@desc   Auth user & get token
//@Route  POST /api/user/login
//access  Public
const authUser = asyncHandler(async (req,res)=>{
   const {email,password} = req.body // get the data from request body which is in json and put it in variables called user and password
   const user = await User.findOne({email:email}) // mongoDb query to get username & Password
   if (user && (await user.matchPassword(password))){ // match password is a custom function that we have written in userModel.js that compares the current plain text password with encrypted password in the DB.
       res.json({
           _id:user._id,
           name:user.name,
           email : user.email,
           isAdmin : user.isAdmin,
           token : generateToken(user._id), // token is generated by using a custom function and jsonwebtoken library. The custom function is available is utils/generatetokens.js
       })
   }
   else{
       res.status("401")
       throw new Error('Invalid username/Password')
   }
})


//@desc   create User
//@Route  POST /api/user/
//access  Public
const createUser = asyncHandler(async (req,res)=>{
   const {name,email,password} = req.body // get the data from request body which is in json and put it in variables called user and password
   const userExists = await User.findOne({email})
   if(userExists)
    {
        res.status("400")
        throw new Error ("User Already exists")
    }
    else
    {
        const salt = await bcrypt.genSalt(10) // generate salt for bcrypt hash rounded to 10
       const Hashedpassword = await bcrypt.hash(password,salt)
       const user =  await User.create({
           name,
           email,
           password:Hashedpassword, // this is hashed at models.js but can also be hashed here.
       })

       if(user){
        res.status(201).json(
            {
            _id:user._id,
           name:user.name,
           isAdmin : user.isAdmin,
           token : generateToken(user._id),
            }
        )
    }
    else{
        res.status("400")
        throw new Error ("400 Bad Request: Please try again later. ")
    }
    }

    
   
})

//@desc   get user profile
//@Route  POST /api/users/profile
//access  Private
const getUserProfile = asyncHandler(async (req,res)=>{
  const user = await User.findById(req.user.id)
  if(user){
      res.json({
           _id:user._id,
           name:user.name,
           email:user.email,
           isAdmin : user.isAdmin,
        
       })

  }
  else{
      res.status('404')
      throw new Error ("user Not Found. Please try again")
  }
  
})


//@desc   update user profile
//@Route  PUT /api/users/profile
//access  Private
const updateUserProfile = asyncHandler(async (req,res)=>{
    const user = await User.findById(req.user.id)
    if(user){
        user.name = req.body.name || user.name
        user.email = req.body.email || user.email
        if(req.body.password){
            const salt = await bcrypt.genSalt(10) // generate salt for bcrypt hash rounded to 10
            const Hashedpassword = await bcrypt.hash(req.body.password,salt)
            user.password = Hashedpassword
        }
       
        const updatedUser = await user.save()
        res.json({
            _id:updatedUser._id,
            name:updatedUser.name,
            email:updatedUser.email,
            isAdmin : updatedUser.isAdmin,
            token : generateToken(updatedUser._id), // token is generated by using a custom function and jsonwebtoken library. The custom function is available is utils/generatetokens.js
        })
  
    }
    else{
        res.status('404')
        throw new Error ("user Not Found. Please try again")
    }
    
  })

export {authUser,getUserProfile,createUser,updateUserProfile} 